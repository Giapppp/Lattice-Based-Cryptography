# Cryptanalysis on Lattice-Based Cryptography

Students: 
- Vu Tien Giap - 22520367
- Nguyen Viet Duy - 22520336

Lecturer: Nguyen Ngoc Tu

## Overview

In the ever-evolving landscape of technology, the government agency recognizes the imperative to fortify its communication infrastructure against the looming threat of quantum advancements. As quantum computers inch closer to reality, the conventional cryptographic protocols currently safeguarding sensitive governmental information become susceptible to rapid decryption. In response to this imminent challenge, the agency contemplates the adoption of lattice-based cryptographic algorithms for post-quantum secure communications.

Lattice-based cryptography offers a unique and promising solution tailored to the agency's security needs. The inherent resilience of lattice-based algorithms to quantum attacks aligns seamlessly with the agency's mandate to ensure the confidentiality and integrity of classified information, even in the face of quantum computational capabilities. In this project, we will talk about lattice - introduction, lattice reduction algorithms and lattice problems. We will also discuss about Learning With Error (LWE) problem and cryptosystems using it

## Mathematical Background

### What is lattice ? 

![](https://miro.medium.com/v2/resize:fit:828/format:webp/1*CEe-dyhTgNNnvsYf4MGAKQ.png)

A __lattice__ [1] is a set of points in $n$-dimensional space with a periodic structure, such as the one illustrated in Figure 1. More formally, given $n$-linearly independent vectors **$b_1, b_2,...,b_n \in \mathbb{R}^n$**, the lattice generated by them is the set of vectors $$\mathcal{L}(b_1, b_2,...,b_n) =  \Bigg\lbrace \sum_{i=1}^nx_ib_i:x_i \in \mathbb{Z} \Bigg\rbrace$$ 

The vectors $b_1, b_2,...,b_n$ are known as a __basis__
of the lattice. A basis can be represented by the matrix $\bf{B} = [b_1, b_2,...,b_n] \in \mathbb{R}^{n \times n}$ having the basis vectors as columns. Using matrix notation, the lattice generated by a matrix $\bf{B} \in \mathbb{R}^{n \times n}$ can be defined as $\mathcal{L}(\bf{B}) = \{ \bf{B}x:x \in \mathbb{Z}^n \}$, where $\bf{B}x$ is the usual matrix-vector multiplication

### Lattice problems

The most well known computational problems on lattices are the following:

- __Shortest Vector Problem (SVP)__: Given a lattice basis $\bf{B}$, find the shortest nonzero vector in $\mathcal{L}(\bf{B})$

![](Screenshot%202023-11-27%20134112.png)

- __Closest Vector Problem (CVP)__: Given a lattice basis $\bf{B}$ and a target vector $\bf{t}$ (not necessarily in the lattice), find the lattice point $\bf{v} \in \mathcal{L}(\bf{B})$ closest to $\bf{t}$

![](Screenshot%202023-11-27%20134130.png)

- __Shortest Independent Vectors Problem (SIVP)__: Given a lattice basis $\bf{B} \in \mathbb{R}^{n \times n}$, find $n$ linearity independent lattice vectors $\bf{S} = [s_1, s_2,...,s_n]$ (where $s_i \in \mathcal{L}(\bf{B})$ for all $i$) so that $max||v_i|| \le max||b_i||$, where $||x|| = \sqrt{x_1^2 + x_2^2 +...+ x_n^2}$

![](https://www.researchgate.net/publication/340108818/figure/fig1/AS:872521280811015@1585036692903/A-good-basis-green-has-short-and-nearly-orthogonal-vectors-while-a-bad-basis-red-is.png)
### Learning With Error (LWE) 

We will give an introduction of LWE:

__Definition:__ Let $n, q$ be positive integers, $\mathcal{X}$ be a probability distribution on $\mathbb{Z}$ and $\bf{s}$ be a uniformly random vector in $\mathbb{Z}_q^n$. We denote by $L_{s, \mathcal{X}}$ the probability distribution on $\mathbb{Z}_q^n \times \mathbb{Z}_q$ obtained by choosing $\bf{a} \in \mathbb{Z}_q^n$ uniformly at random, choosing $\bf{e} \in \mathbb{Z}$ according to $\mathcal{X}$ and considering it in $\mathbb{Z}_q$, and returning $(\bf{a}, c) = (\bf{a}, \bf{<a, s>} + e) \in \mathbb{Z}_q^n \times \mathbb{Z}_q$ sampled according to $L_{s, \mathcal{X}}$

We have two computational problems in LWE:

__Decision LWE:__ The problem of deciding whether pairs $(\bf{a}, c) \in \mathbb{Z}_q^n \times \mathbb{Z}_q$ are sampled according to $L_{s, \mathcal{X}}$ or the uniform distribution on $\mathbb{Z}_q^n \times \mathbb{Z}_q$

__Search LWE:__ The problem of recovering $\bf{s}$ from pairs $(\bf{a}, c) \in \mathbb{Z}_q^n \times \mathbb{Z}_q$ sampled according to $L_{s, \mathcal{X}}$

In this project, we will implicitly assume that $\mathcal{X}$ is centered, i.e. has expectation 0. We may also write LWE in matrix form as $B * s + e = c \mod q$

The hardness of LWE problems are the same as SVP and CVP

## Proposed Solution

### Solution Architecture

#### Key Generation and Collection

We will focus on the LWE-based public key cryptosystem:

__Parameter__: We let $n$ be the security parameter of the cryptosystem. The cryptosystem is parameterized by two integers $m, p$ and a probability distribution $\mathcal{X}$ on $\mathbb{Z}_p$. The setting of these paramteters that guarantees both security and correctness is the following:

- Prime $p > 2 \in (n^2, 2n^2)$ 
- $m = (1 + \varepsilon)(n + 1) \log p$ for some arbitrary constant $\varepsilon > 0$
- The probability distribution $\mathcal{X}$ is taken to be $\Psi_{\alpha(n)}$ for $\alpha(n) = o(1/\sqrt{n}\log n)$, i.e., $\alpha(n)$ is such that $\lim\limits_{n \to \infty} \alpha(n) * \sqrt{n}\log n = 0$. For example, we can choose $\alpha(n) = 1/(\sqrt{n}\log n)$

__Private Key:__ Choose $\bf{s} \in \mathbb{Z}_p^n$ uniformly at random. The private key is $\bf{s}$

__Public Key:__ For $i = 1,...m$, choose $m$ vectors $a_1, a_2,...,a_m \in \mathbb{Z}_p^n$ independently from the uniform distribution. Also choose elements $e_1, e_2,...,e_m \in \mathbb{Z}_p$ independently according to $\mathcal{X}$. The public key is given by $(\bf{a}_i, b_i)^m_{i = 1}$ where $b_i = <\bf{a_i}, s> + e_i$

__Encryption:__ In order to encrypt a bit we choose a random set $S$ uniformly among all $2^m$ subsets of $[m]$. The encryption is $(\sum_{i \in S}\bf{a}_i, \sum_{i \in S}b_i)$ if the bit is $0$ and $(\sum_{i \in S}\bf{a}_i, [\frac{p}{2}] + \sum_{i \in S}b_i)$ if the bit is $1$

__Decryption:__ The decryption of a pair $(\bf{a}, b)$ is $0$ if $b-\langle{\bf{a}, s}$ is closer to 0 than to $[\frac{p}{2}]$ modulo $p$. Otherwise, the decryption is $1$

![](Screenshot%202023-11-27%20134636.png)

#### Cryptanalysis Tools

- C/C++, Python 3.x

- Number Theory Library (NTL): NTL is a C++ library for doing number theory. NTL supports arbitrary length integer and arbitrary precision floating point arithmetic, finite fields, vectors, matrices, polynomials, lattice basis reduction and basic linear algebra. NTL is free software released under the GNU Lesser General Public License v2.1.

- Sagemath: SageMath is a computer algebra system with features covering many aspects of mathematics, including algebra, combinatorics, graph theory, group theory, differentiable manifolds, numerical analysis, number theory, calculus and statistics. Stein realized when designing Sage that there were many open-source mathematics software packages already written in different languages, namely C, C++, Common Lisp, Fortran and Python.

- Numpy: NumPy is a library for the Python programming language, adding support for large, multi-dimensional arrays and matrices, along with a large collection of high-level mathematical functions to operate on these arrays.

### Attack Models

#### A. Lattice reduction

#### 1. Lenstra–Lenstra–Lovász reduction

The Lenstra–Lenstra–Lovász (LLL) lattice basis reduction algorithm is a polynomial time lattice reduction algorithm invented by Arjen Lenstra, Hendrik Lenstra and László Lovász in 1982.[2] Given a basis $\bf{B = \{b_1, b_2,...,b_d\}}$ with $n$-dimensional coordinates, for a lattice $\bf{L}$ with $d \le n$, the LLL algorithm calculated an <em>LLL-reduced</em> (short, nearly orthogonal) lattice basis in time $$\mathcal{O}(d^5n\log^3B)$$ where $B = max(||b_1||, ||b_2||,...,||b_d||)$

<u>__Algorithm:__</u>

We first recall the Gram-Schmidt orthogonalization process

__Definition 1:__ Given $n$ linearly independent vectors $b_1, b_2,...,b_n \in \mathbb{R}^n$, the __Gram-Schmidt orthogonalization__ of $b_1, b_2,...,b_n$ is defined by $b_i^* = b_i - \sum_{j=1}^{i-1}\mu_{i, j}b_j^*$, where $\mu_{i, j} = \frac{\langle{b_i, b_j^*}\rangle}{\langle{b_j^*, b_j^*}\rangle}$

__Definition 2:__ A basis $B = {b_1, b_2,...,b_n} \in \mathbb{R}^n$ is a δ-__LLL Reduced Basis__ if the following holds:

- $\forall 1 \le i \le n, j \lt i * |\mu_{i, j}| \le 0.5$
- $\forall 1 \le i \le n, \delta||b_i^*||^2 \le ||\mu_{i+1, i}*b_i^* + b_{i+1}^*||^2$

We will consider the case $\delta = 0.75$

Now we will look at LLL-algorithm:

__LLL-algorithm:__

<u>Input:</u> Lattice basis $b_1, b_2,...,b_n \in \mathbb{Z}^n$

<u>Output:</u> δ-__LLL-reduced basis__ for $\mathcal{L}(B)$

1. Compute $b_1^*, b_2^*,...,b_n^*$

2. Reduction Step

$\hspace{1cm}$ __for__ $i = 2$ to $n$ do:

$\hspace{1.5cm}$ __for__ $j = i - 1$ to $1$ do:

$\hspace{2cm}$ $b_i \gets b_i - c_{i, j}b_j$, where $c_{i, j} = [\langle{b_i, b_j^*}\rangle/\langle{b_j^*, b_j^*}\rangle]$

3. Swap step

$\hspace{1cm}$ __if__ exist $i$ $\ s.t. \ \delta||b_i^*||^2 \gt ||\mu_{i+1, i}*b_i^* + b_{i+1}^*||^2$ __then:__

$\hspace{1.5cm}$ $b_i \leftrightarrow b_{i+1}$

$\hspace{1.5cm}$ Back to step 1

4. Return $b_1, b_2,...,b_n$

#### 2. Block Korkine–Zolotarev reduction

The definition of a KZ-reduced basis was given by Aleksandr Korkin and Yegor Ivanovich Zolotarev in 1877, a strengthened version of Hermite reduction. The first algorithm for constructing a KZ-reduced basis was given in 1983 by Kannan.[3]

The block Korkine-Zolotarev (BKZ) algorithm was introduced in 1987.

With a basis $\bf{B} = \{b_1, b_2,...,b_n\} \in \mathbb{R}^{n \times n}$, $\bf{L} = \mathcal{L}(\bf{B})$ we need to definite some concepts before working with BKZ:

- $\lambda_1(\bf{L}) = \min_{\bf{b} \in \bf{L} \setminus\{0\}}||b||$ is the <em>first minimum</em> of $\bf{L}$

- $\bf{B}$ is <em>SVP-reduced</em> if $||\bf{b_1}|| = \lambda_1(\bf{L})$, more general, $\bf{B}$ is <em>δ-SVP-reduced</em> if $||\bf{b_1}||^2 = \delta\lambda_1(\bf{L})^2$

- $\bf{B}$ is <em>size-reduced</em> if $|\mu_{i, j}| < 0.5$ if $ 1 \le i < j \le n$

-  Let $\pi_i$ be the orthogonal projection to $span(b_1, · · · , b_{i−1})^⊥$, or $\pi_i = \displaystyle\sum_{j \ge i}{\langle{x, b_j^*}\rangle \over \langle{b_j^*, b_j^*}\rangle}*b_j^*$. Then we define the local projected lattice $L_{[i,j]}$ to be the lattice spanned by $B_{[i,j]} = (π_i(b_i), · · · , π_i(b_j))$

- $\bf{B}$ is <em>HKZ-reduced</em> if it size-reduced and $B_{[i, n]}$ is SVP-reduced for $i = 1,..,n$

- $\bf{B}$ is <em>(δ, β)-BKZ-reduced</em> if it is size-reduced and $\bf{B}_{[i, \min{i + \beta - 1, n}]}$ is 
δ-SVP-reduced for $i = 1,..,n$

Now we are ready for BKZ Algorithm:

<u>Input:</u> A blocksize $\beta \in (2, n)$, a relaxation factor $\delta \in (1, 2)$, and a basis $\bf{B} = \{b_1, b_2,...,b_n\} \in \mathbb{R}^{n \times n}$ of a lattice $L$ in $\mathbb{Z}^m$

<u>Output:</u> A (δ, β)-BKZ-reduced basis of $L$

1. $z \gets 0$,  $j \gets 0$, ${1 \over \delta}$-LLL reduce $\bf{B}$

2. while $z < n - 1$ do:

3. $\hspace{1.5cm}$ $j \gets (j \mod (n - 1)) + 1$; $n_j \gets \min \{j + \beta - 1, n\}$; $h \gets \min \{j + \beta, n\}$

4. $\hspace{1.5cm}$ Run an enumeration for $\mathcal{L}(B_{[j, n_j]})$ to find $(\alpha_1, \alpha_2,...,\alpha_{n_j}) \in \mathbb{Z}^{n_j - j + 1}$ and compute $\bf{b} = \sum_{i=j}^{n_j} \alpha_i \bf{b}_i$ such that $||\pi_i(\bf{b})|| = \lambda_1(\mathcal{L}(B_{[j, n_j]}))$

5. $\hspace{1.5cm}$ If $||\bf{b}_j^*||^2 > \delta * ||\pi_j({\bf{b}})||^2$ then: 

6. $\hspace{2.5cm}$ $z \gets 0$; ${1 \over \delta}$-LLL reduce $(\bf{b_1, b_2,...,b_{j-1}, b, b_j,...,b_h)}$ at stage $j$

7. $\hspace{1.5cm}$ else

8. $\hspace{2.5cm}$ $z \gets z + 1$; 0.99-LLL-reduce ($\bf{b_1, b_2,...,b_h}$) at stage $h - 1$

9. $\hspace{1.5cm}$ end if

10. End while

11. return $B$

To know more about BKZ, you can read [4]

#### B. Shor's algorithm

- There is no polynomial time quantum algorithm that approximates lattice problems to within polynomial factors

## Implementation and Testing

- C/C++

- Python 3.x

- Sagemath

### Deployment

Lattice-based cryptography is regarded as the rival to a quantum computer attack and the future of post-quantum cryptography. So, cryptographic protocols based on lattices have a variety of benefits, such as security, efficiency, lower energy consumption, and speed

Some selected schemes for the purpose of key exchange, based on LWE problem:

- CRYSTALS-Kyber, [5] which is built upon module learning with errors (module-LWE). Kyber was selected for standardization by the NIST in 2023. [6] In August 2023, NIST published FIPS 203 (Initial Public Draft), and started calling their Kyber version as Module-Lattice-based Key Encapsulation Mechanism (ML-KEM)

- FrodoKEM, [7] a scheme based on the learning with errors (LWE) problem. FrodoKEM joined the standardization call conducted by the National Institute of Standards and Technology (NIST), [8] and lived up to the 3rd round of the process. It was then discarded due to low performance reasons.

- NewHope [9] is based on the ring learning with errors (RLWE) problem.


### Reference

[1]. Wikipedia

[2]. Lenstra, A. K.; Lenstra, H. W. Jr.; Lovász, L. (1982). "Factoring polynomials with rational coefficients". Mathematische Annalen. 261 (4): 515–534. [CiteSeerX 10.1.1.310.318](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.310.318).

[3]. Yasuda, Masaya, (2021). "A Survey of Solving SVP Algorithms and Recent Strategies for Solving the SVP Challenge". [Doi: 10.1007/978-981-15-5191-8_15](https://link.springer.com/chapter/10.1007/978-981-15-5191-8_15)

[4]. https://www.newton.ac.uk/files/seminar/20140509093009501-202978.pdf

[5]. https://pq-crystals.org/

[6]. https://csrc.nist.gov/Projects/post-quantum-cryptography/selected-algorithms-2022

[7]. https://newhopecrypto.org/index.shtml

[8]. https://csrc.nist.gov/events/2019/second-pqc-standardization-conference

[9]. https://frodokem.org/
